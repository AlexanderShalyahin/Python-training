#506. Створіть словник з інформацією про пошукові системи, в якому ключі – назви пошукових систем,
# а значення – частка їхнього використання у світі на даний момент (дійсне число).
# Надрукуйте елементи словника як у вихідних даних. Елементи у словнику невпорядковані.
# some_dict = {
#     'Yahoo!': 2.09,
#     'Google': 90.15,
#     'Bing': 3.23,
#     'Baidu': 2.2
# }
# for key, values in some_dict.items():
#     print(key, values, sep=': ')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#507. Створіть словник зі списками добрих справ на сьогодні і на завтра. Надрукуйте із словника добрі справи, які плануєш зробити сьогодні і взавтра.
# good_things = {
#     'today': ['Make a compliment to a friend', 'Call your grandparents', 'Embrace parents'],
#     'tomorrow': ['Feed the birds in the park', 'Give unnecessary things to those who need them', 'Smile']
# }
# for key, values in good_things.items():
#     print(key,':', sep='')
#     for i in values:
#         print(i)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#508. Припустимо, що у нас є словник, в якому ключі є ідентифікаторами, а значення – іменами користувачів.
# Напишіть програму, яка виводить вітальне повідомлення користувачу на основі його ідентифікатора. Якщо ідентифікатор відсутній у словнику, виводиться вітання для усіх користувачів.
# while True:
#     say_hi = input('hi to: ')
#
#     if say_hi == 'done':
#         break
#
#     some_names = {
#         232: 'Alice',
#         550: 'Bob',
#         190: 'Jack'
#     }
#
#     if int(say_hi) in some_names:
#         print(f'Hi, {some_names[int(say_hi)]}!')
#     else:
#         print('Hi, to all!')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#509. Ви створюєте пригодницьку гру і використовуєте для зберігання предметів гравця словник,
# у якому ключі - це назви предметів, значення - кількість одиниць кожної із речей.
# Виведіть повідомлення про усі речі гравця як у вихідних даних.
# loot = {
#     'key': 3,
#     'mace': 1,
#     'gold coin': 24,
#     'lantern': 1,
#     'stone': 10
# }
#
# print('Equipment:')
#
# for keys, values in loot.items():
#     print(values, keys)
#
# total_num_of_things = sum(loot.values())
#
# print(f'Total number of things: {total_num_of_things}')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#510. Напишіть програму для сортування за зростанням (за алфавітом) словника за ключами.
# Словник зберігає пари ключ-значення у вигляді «назва фільму: рік релізу».
# Інформація виводиться як у вихідних даних: сортування має бути проведено за назвами фільмів.
# movies_dikt = {
#     'Thor' : 2011,
#     'Iron Man': 2008,
#     'Guardians of the Galaxy': 2014,
#     'Avengers: Endgame': 2019
# }
#
# lst_movies = []
#
# for item in movies_dikt.items():
#     lst_movies.append(item)
#
# lst_movies.sort()
#
# print(*lst_movies)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#511. Напишіть програму для сортування за спаданням (порядок, зворотний алфавітному) словника за ключами.
# Словник зберігає пари ключ-значення у вигляді «країна: столиця».
# Інформація виводиться як у вихідних даних: сортування має бути проведено за назвами країн.
# countries = {
#     'China': 'Beijing',
#     'Ukraine': 'Kyiv',
#     'France': 'Paris',
#     'Canada': 'Ottawa',
#     'Denmark': 'Copenhagen'
# }
#
# countries_reversed = sorted(countries.items(), reverse=True)
# print(countries_reversed)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#512. Надрукуйте елементи словника, де ключі - це числа від 1 до n (обидва числа включно),
# а значення - квадрати ключів. n – ціле число, яке вводить користувач.
# num = 15
# number_dikt = {}
# count = 0
#
# while count < num:
#     number_dikt[count+1] = (count+1)**2
#     count += 1
# print(number_dikt)
#******************************OR*************************************
# num = int(input('enter: '))
# num_dikt = {}
#
# for i in range(1, num+1):
#     num_dikt[i] = i**2
# print(num_dikt)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#513. Створіть словник, в кому ключі – назви днів тижня, а значення - цілі числа, що позначають порядковий номер дня тижня від 0 до 6.
# Надрукуйте назву дня за введеним порядковим номером дня.
# Якщо введений номер виходить за межі, програма жодних повідомлень не друкує і не повідомляє про помилку.
# num = 0
# days_dikt = {
#     'Monday': 0,
#     'Tuesday': 1,
#     'Wednesday': 2,
#     'Thursday': 3,
#     'Friday': 4,
#     'Saturday': 5,
#     'Sunday': 6
# }
#
# for days, numbers in days_dikt.items():
#     if numbers == num:
#         print(days)
#     else:
#         print('')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#514. Створіть словник у якому ключами є назви жанрів комп’ютерних ігор, а значеннями - назва конкретної гри даного жанру.
# Виведіть вміст словника як у вихідних даних.
# games = {
#     'simulations': 'Euro Track Simulator',
#     'adventure': 'Myst',
#     'rts': 'Kingdom Two Crowns',
#     'action': 'Grand Theft Auto',
#     'sports': 'FIFA'
# }
#
# for k, v in games.items():
#     print(f'{k}: {v}')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#515. Дано словник, у якому ключами є назви платних застосунків для платформи Android,
# а значеннями - їх ціна (дійсне число, два знаки після десяткової крапки).
# Надрукуйте із словника через кому з пропуском максимальну і мінімальну ціни для застосунків.
# android_app = {
#     'Dream by WOMBO': 179.00,
#     'Todoist': 50.00,
#     'TickTick': 40.45,
#     'Any.do': 14.99,
#     'Saldo': 5.00,
#     'Monobudget': 71.99,
#     'Coin Flow': 15.99
# }
# print(f'{max(android_app.values())}, {min(android_app.values())}')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#516. Напишіть програму для створення словника із введеного рядка символів для підрахунку кількості символів.
# s = 'Lorem ipsum dolor sit amet'
# some_dikt = {}
#
# for i in list(s):
#     if i not in some_dikt:
#         some_dikt[i] = 1
#     else:
#         some_dikt[i] += 1
#
# print(some_dikt)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#517. Створіть словник, у якому ключі - імена відомих програмістів, а значення - їхні дати народження у форматі dd/mm/yyyy.
# Напишіть програму, яка за введеним ім’ям відомого інформатика друкує його дату народження або
# у відсутності такого - відповідне повідомлення як у вихідних даних.
# person = {
#     'Тарас Шевченко': '9.03. 1814',
#     'Іван Франко': '27.08.1856',
#     'Василь Стус': '06.01.1938',
#     'Павло Тичина': '27.01.1891',
#     'Ліна Костенко': '19.03.1930'
# }
# name = input('Enter: ')
#
# if name in person:
#     print(f'День народження {name} - {person[name]}')
# else:
#     print('Нажаль, дата народження цієї людини, поки що, нам не відома. ')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#518. Створіть словник, що містить назви продуктів в уявному холодильнику.
# Найменування їжі будуть ключами, а відповідне значення кожного продукту харчування має бути значенням-рядком, що описує їжу.
# Після введення користувачем назви продукту, виведіть повідомлення про наявність або відсутність його у холодильнику.
# product_in_fridge ={
#     'butter': 'butter is a dairy product with high butterfat content',
#     'eggs': 'eggs are a high-protein product',
#     'bananas': 'cold temperatures affect the structure of bananas, leading to rapid browning of the peel and loss of aroma',
#     'tomatoes': 'low temperatures degrade the texture of tomatoes, making them soft and flavorless',
#     'honey': 'in the refrigerator, honey crystallizes and loses its beneficial properties',
#     'Bread': 'storing bread in the refrigerator leads to rapid staling and loss of taste qualities',
#     'olive oil': 'when stored in the refrigerator, olive oil can thicken'
# }
# finding_product_in_fridge = input('What do you need: ')
#
# print(product_in_fridge.get(finding_product_in_fridge, f"{finding_product_in_fridge} wasn't found in the fridge"))
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#519. Напишіть програму, яка приймає рядок символів, і обчислює кількість букв і цифр.
# s = 'Project Gutenberg offers over 59,000 free eBooks'
# some_dict = {
#     'LETTERS': 0,
#     'DIGITS': 0
# }
#
# for simbols in list(s):
#     if simbols.isalpha():
#         some_dict['LETTERS'] += 1
#     elif simbols.isdigit():
#         some_dict['DIGITS'] += 1
#
# for k, v in some_dict.items():
#     print(f'{k} {v}')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#520. Напишіть програму, яка приймає рядок символів, і обчислює кількість великих та малих літер.
# s = 'The quick brown FOX jumps over a lazy DOG'
# some_dict = {
#     'UPPER CASE': 0,
#     'lower case': 0
# }
#
# for simbols in list(s):
#     if simbols.isupper():
#         some_dict['UPPER CASE'] += 1
#     elif simbols.islower():
#         some_dict['lower case'] += 1
#
# for k, v in some_dict.items():
#     print(f'{k} {v}')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 521. Створіть словник із даними про студентів: ключі - імена студентів, значення - бали для кожного.
# Програма повинна визначити середній бал і вивести імена студентів, чий бал вище середнього.
# students_and_grades = {
#     'Олекса': 12,
#     'Стас': 10,
#     'Іван': 6,
#     'Степан': 5,
#     'Мартин': 2,
#     'Костя': 4,
#     'Марта': 9,
#     'Настя': 7,
#     'Іванна': 10,
#     'Максим': 8,
#     'Аня': 7
# }
#
# # midle_grade = round(sum(students_and_grades.values()) / len(students_and_grades))
#
# for names, grades in students_and_grades.items():
#     if grades > round(sum(students_and_grades.values()) / len(students_and_grades)):
#         print(names)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 522. Напишіть програму для підрахунку кількості символів (символьної частоти) у введеному рядку.
# word = 'google'
# simbols = {}
#
# for i in word:
#     if i not in simbols:
#         simbols[i] = 1
#     else:
#         simbols[i] += 1
#
# for letter, values in simbols.items():
#     print(f'{letter} {values}')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#523. Створіть англо-німецький словник з назвою e2g і виведіть його вміст на екран.
# e2g = {
#     'stork': 'storch',
#     'hawk': 'falke',
#     'woodpecker': 'specht',
#     'owl': 'eule'
# }
#
# for e, g in e2g.items():
#     print(f'{e}: {g}')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#524. Словники можуть використовуватися для моделювання справжнього словника.
# Оберіть кілька термінів з програмування (або із іншої області), які ви знаєте на цей момент.
# Використайте ці слова як ключі словника, а їх визначення - як значення.
# Виведіть кожне слово і його визначення у спеціально відформатованому вигляді як у вихідних даних.
# some_terms_dicy = {
#     'variable': 'a symbolic name associated with a value and whose associated value may be changed',
#     'type': 'is a classification of data which tells the compiler or interpreter how the programmer intends to use the data',\
#     'program': 'a collection of instructions that performs a specific task when executed by a computer'
# }
#
# for word, value in some_terms_dicy.items():
#     print(f'{word}\n    {value}')
#     print(word+'\n'+'\t'+value) # or like this
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#525. Cтворіть словник з річками і регіонами, територією яких вони протікають.
# Виведіть повідомлення із назвами річки і регіону, як у вихідних даних, для усіх елементів словника, враховуючи те,
# що у повідомлення підставляються назви річок і територій із словника.
# some_river_dict = {
#     'Amazon': 'South America',
#     'Odra': 'Central Europe',
#     'Ganges': 'South Asia'
# }
#
# for river, region in some_river_dict.items():
#     print(f'The {river} runs through {region}.')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#526. Створіть словник з назвами мов програмування (ключі) та іменами розробників цих мов (значення).
# Виведіть по черзі для усіх елементів словника повідомлення як у вихідних даних.
# developers_dict = {
#     'JavaSript': 'Brendan Eich',
#     'Python': 'Guido van Rossum',
#     'Ruby': 'Yukihiro Matsumoto',
#     'PHP': 'Rasmus Lerdorf'
# }
#
# for language, developer in developers_dict.items():
#     print(f'My favorite programming language is {language}. It was created by {developer}.')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#527. Використайте словник для виведення представлення букви, яку вводить користувач, у символах азбуки Морзе.
# Передбачте у програмі обробку малих і великих букв.
# morze_dict = {
# 'A': '.-',
# 'B': '-...',
# 'C': '-.-.',
# 'D': '-..',
# 'E': '.',
# 'F': '..-.',
# 'G': '--.',
# 'H': '....',
# 'I': '..',
# 'J': '.---',
# 'K': '-.-',
# 'L': '.-..',
# 'M': '--',
# 'N': '-.',
# 'O': '---',
# 'P': '.--.',
# 'Q': '--.-',
# 'R': '.-.',
# 'S': '...',
# 'T': '-',
# 'U': '..--',
# 'V': '...-',
# 'W': '.--',
# 'X': '-..-',
# 'Y': '-.--',
# 'Z': '--..',
# ' ': ''
# }
#
# while True:
#     some_text = input("enter: ").upper()
#
#     if some_text == 'DONE':
#         break
#
#     for simbol in some_text:
#         print(morze_dict.get(simbol, 'putin xyulo!!!'))
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#528. Створіть кілька словників, імена яких - це клички домашніх тварин.
# У кожному словнику збережіть інформацію про вид домашнього улюбленця та ім’я власника.
# Збережіть словники в списку з ім’ям pets. Виведіть повідомленя як у вихідних даних.
# little_kity = {
#     'owner': 'Jim',
#     'type of pet': 'cat'}
# snoopy = {
#     'owner': 'Alex',
#     'type of pet': 'dog'}
# pirat = {
#     'owner': 'Olena',
#     'type of pet': 'parrot'}
#
# lst_pets = [little_kity, snoopy, pirat]
#
# for i in lst_pets:
#     print(f"{i['owner']} is the owner of a pet - a {i['type of pet']}.")
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 529. Створіть словник для зберігання інформації про міста. Використайте назви міст в якості ключів словника.
# Створіть словник з інформацією про кожне місто:
# включіть в нього країну, в якій розташоване місто,
# приблизну чисельність населення
# і один цікавий факт про місто.
# Виведіть назву кожного міста і всю збережену інформацію про нього як у вихідних даних.
# cities = {
#     'Rome': {
#         'Country': 'Italy',
#         'Population': '2868000 people',
#         'Fact': 'Rome is one of the oldest cities in the world, the capital of Ancient Rome. Therefore, Rome is often called the "eternal city".'
#     },
#     'Canberra': {
#         'Country': 'Australia',
#         'Population': '381448 people',
#         'Fact': 'The design of Canberra was based on the concept of a garden city, which includes significant areas of natural vegetation, '
#                 'which earned for Canberra the title of "bush capital" (translated from the English "forest capital").'
#     },
#     'Toronto': {
#         'Country': 'Canada',
#         'Population': '2503281 people',
#         'Fact': 'In the world of professional sports, the city is the most famous hockey team of Toronto Maple Leafs. '
#                 'The city holds the nickname of the "hockey universe center".'
#     }
# }
#
# for city, value in cities.items():
#     print(f'{city}:')
#     for keys, facts in value.items():
#         print(f'\t{keys}: {facts}')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#530. Створити словник, у кому ключами є назви команд Національної баскетбольної асоціації (NBA) у північній Америці,
# а значеннями - списки, на зразок, [Всього ігор, Перемог, Нічиїх, Поразок, Всього очок].
# Значення списку - це цілі числа, які обираються довільно. Надрукуйте інформацію про кожну команду як у вихідних даних.
# teems = {
#     'BOSTON CELTICS': [3, 2, 0, 1, 8],
#     'NEW YORK KNICKS': [10, 3, 3, 4, 19],
#     'INDIANA PACERS': [4, 2, 2, 0, 11],
#     'MIAMI HEAT': [12, 2, 5, 5, 9],
#     'ATLANTA HAWKS': [5, 2, 2, 1, 10],
#     'CHICAGO BULLS': [25, 10, 9, 6, 38]
# }
#
# print('{:^17s}|{:^20s}'.format('Teem', 'Points'))
# print('---------------------------------------')
#
# for teem, points in teems.items():
#     score = ''
#     for i in points:
#         score += '{:>3s}|'.format(str(i))
#     print('{:<17s}|'.format(teem), score)
#     print('---------------------------------------')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#531. Дано місяць і рік для двох дат (наприклад, 12.2014 і 6.2019). Користувач вводить ще одну дату (місяць і рік).
# Визначити, чи належить третя дата діапазону від першої дати до другої включно. Результатом роботи програми має бути повідомлення YES або NO.
# dates = {
#     2014: [12],
#     2015: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
#     2016: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
#     2017: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
#     2018: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
#     2019: [1, 2, 3, 4, 5, 6]
#     }
#
# year = int(input('year: '))
# month = int(input('month: '))
#
# if year in dates.keys() and month in dates[year]:
#     print('YES')
# else:
#     print('NO')
#*******************a more automated option*****************
# start_year = 2014
# start_month = 12
#
# end_year = 2019
# end_month = 6
#
# some_date_dict = {}
# year_count = start_year
#
# while year_count <= end_year:
#     month_lst = []
#
#     if year_count == start_year:
#         for i in range(start_month, 13):
#             month_lst.append(i)
#     elif year_count == end_year:
#         for i in range(1, end_month+1):
#             month_lst.append(i)
#     else:
#         for i in range(1, 13):
#             month_lst.append(i)
#
#     if year_count not in some_date_dict.keys():
#         some_date_dict[year_count] = month_lst
#
#     year_count += 1
#
# user_year = int(input('year: '))
# user_month = int(input('month: '))
#
# if user_year in some_date_dict.keys() and user_month in some_date_dict[user_year]:
#     print('YES')
# else:
#     print('NO')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#532. Написати програму, в якій зберігаються дані про товари, їх кількість і ціну. При запуску програми ця інформація виводиться на екран.
# Далі користувачеві має пропонуватися вводити номера товарів і їх нову кількість. Введення даних має завершуватися,
# якщо користувач вводить обумовлений символ (наприклад, нуль). Після цього всі дані про товари повинні знову виводитися на екран.
# Якщо номер товару відсутній, необхідно вивести відповідне повідомлення як у вихідних даних.
# goods_dict = {
#     'Core-i3-4330': [9, 4500],
#     'Core i5-4670K': [3, 8500],
#     'AMD FX-6300': [6, 3700],
#     'Pentium G3220': [8, 2100],
#     'Core i5-3450': [5, 6400]
# }
#
# print('{:<3s} {:<15s} {:^8s} {:<6s}'.format('#', 'article', 'quantity', 'price'))
# count = 0
# for article, values in goods_dict.items():
#     count += 1
#     print('{:<3d} {:<15s} {:^8d} {:<6d}'.format(count, article, values[0], values[1]))
#
# product_number = int(input('Enter a product number: '))
# new_quantity_of_goods = int(input('Enter a new quantity: '))
#
# print('{:<3s} {:<15s} {:^8s} {:<6s}'.format('#', 'article', 'quantity', 'price'))
# count = 0
# for article, values in goods_dict.items():
#     count += 1
#
#     if count == product_number:
#         goods_dict[article][0] = new_quantity_of_goods
#
#     print('{:<3d} {:<15s} {:^8d} {:<6d}'.format(count, article, values[0], values[1]))
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#533. Дано словник, в якому ключі - імена та прізвища, записані через пропуск, відомих розробників мов програмування,
# а значення - назви мов програмування. Надрукуйте назву мови за введеним ім’ям або прізвищем її розробника.
# founders = {
# 'Dennis Ritchie': 'C(1972)',
# 'Bjarne Stroustrup': 'C++ (1983)',
# 'Guido van Rossum': 'Python (1991)',
# 'James Gosling': 'Java (1995)',
# 'Rasmus Lerdorf': 'PHP (1995)',
# 'Brendan Eich':'JavaScript (1995)',
# 'John McCarthy': 'Lisp (1958)',
# 'Grace Hopper': 'COBOL (1959)',
# 'Niklaus Wirth': 'Pascal (1970)',
# 'Yukihiro Matsumoto': 'Ruby (1995)'
# }
#
# name = input('Enter a name of founder: ')
#
# result = 0
# for key in founders.keys():
#     if name in key:
#         result += 1
#         print(founders[key])
#
# if result == 0:
#     print('There are no this name. Maybe it is not a founder?')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#534. Змоделюйте аркуш елетронної таблиці на основі словника. Створіть порожній словник для зберігання значень комірок аркушу електронної таблиці.
# Заповніть словник кількома значеннями: в одному рядку вводиться адреса комірки у форматі A1,
# де A - назва стовпця, 1 - номер рядка,
# і, через пропуск, значення, яке необхідно зберегти в комірці.
# Надрукуйте «комірки» словника з їхніми значеннями.
# table = {}
#
# while True:
#     table_place = input('Where to save?  -  ')
#
#     if table_place == 'stop':
#         break
#
#     lst = table_place.split()
#     table[lst[0]] = lst[1]
#
# for k, v in table.items():
#     print(tuple(list(k)), v)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#535. Напишіть програму для видалення дублікатів зі списку цілих чисел.
# numbers = [10, 5, 11, 2, 3, 5, 8, 9, 3, 4, 2]
# print(*set(numbers))
#*********  or  *******************************************
# numbers = [10, 5, 11, 2, 3, 5, 8, 9, 3, 4, 2]
# num = dict.fromkeys(numbers)
# print(*sorted(list(num)))
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#536. Даний список цілих чисел. Визначте кількість різних значень.
# lst = [1, 3, 4, 5, 6, 5, 1, 9]
#
# print(len(dict.fromkeys(lst)))
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#537. Дано список словників. Кожен словники має 2 пари елементів: ключ name і значення імені студента, ключ points і
# значення - список балів з різних дисциплін (цілі двоцифрові числа).
# Надрукуйте найменші значення балів, отримані кожним студентом, в один рядок з пропуском.
# students_lst = [
# {'name': 'Jeme', 'points': [65, 70 , 55, 45]},
# {'name': 'Bob', 'points': [95, 85 , 60, 70]},
# {'name': 'Ann', 'points': [55, 70 , 95, 30]},
# {'name': 'Alice', 'points': [60, 75, 84, 49]}
# ]
#
# lst = []
#
# for student in students_lst:
#     lst.append(min(student['points']))
# print(*lst)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#538. Дано два списки чисел. Порахуйте, скільки унікальних цифр міститься в обох з них.
from itertools import count
from sys import set_coroutine_origin_tracking_depth
from wsgiref.simple_server import software_version

# first_lst = [1, 6, 3, 5, 6]
# second_lst = [10, 12, 6, 5, 1, 4]
#
# s = ''
# for i in first_lst + second_lst:
#     s += str(i)
#
# result = ''
# for i in list(s):
#     if list(s).count(i) == 1:
#         result += i
#
# print(len(result))
#**************** do the same thing with dict using***************
# first_lst = [1, 6, 3, 5, 6]
# second_lst = [10, 12, 6, 5, 1, 4]
#
# s = ''
# for i in first_lst + second_lst:
#     s += str(i)
#
# some_dict ={}
# for i in list(s):
#     if i not in some_dict:
#         some_dict[i] = 1
#     else:
#         some_dict[i] += 1
#
# count = 0
# for value in some_dict.values():
#     if value == 1:
#         count += 1
# print(count)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#539. Дано два словники, в яких ключами є малі букви латинського алфавіту, а значеннями - цілі числа.
# В першому словнику можуть зустрічатися ключі чи значення, які присутні в другому словнику, або навпаки.
# Наприклад, вміст словників може бути наступний: a = {'x' : 1, 'y' : 2, 'z' : 3}, b = {'w' : 10, 'x' : 11, 'y' : 2}.
# Надрукуйте спільні ключі для обох словників в одному рядку через пропуск.
# a = {
#     'x' : 1,
#     'y' : 2,
#     'z' : 3
# }
# b = {
#     'w' : 10,
#     'x' : 11,
#     'y' : 2
# }
#
# lst = []
# for keys in a.keys():
#     if keys in b:
#         lst.append(keys)
# print(*lst)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#540. Дано два словники, в яких ключами є малі букви латинського алфавіту, а значеннями - цілі числа.
# В першому словнику можуть зустрічатися ключі чи значення, які присутні в другому словнику, або навпаки.
# Наприклад, вміст словників може бути наступний: a = {'x' : 1, 'y' : 2, 'z' : 3}, b = {'w' : 10, 'x' : 11, 'y' : 2}.
# Надрукуйте ключі, які присутні в першому словнику, але яких немає в другому, в одному рядку через пропуск.
# a = {
#     'x' : 1,
#     'y' : 2,
#     'z' : 3
# }
# b = {
#     'w' : 10,
#     'x' : 11,
#     'y' : 2
# }
# lst = []
#
# for key in a.keys():
#     if key not in b:
#         lst.append(key)
# print(*lst)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#541. Дано два словники, в яких ключами є малі букви латинського алфавіту, а значеннями - цілі числа.
# В першому словнику можуть зустрічатися ключі чи значення, які присутні в другому словнику, або навпаки.
# Наприклад, вміст словників може бути наступний: a = {'x' : 1, 'y' : 2, 'z' : 3}, b = {'w' : 10, 'x' : 11, 'y' : 2}.
# Надрукуйте спільні пари «ключ-значення» для обох словників у форматі як у вихідних даних.
# a = {
#     'x' : 1,
#     'y' : 2,
#     'z' : 3,
# }
# b = {
#     'w' : 10,
#     'x' : 11,
#     'y' : 2,
# }
#
# for key, value in a.items():
#     if key in b.keys() and a[key] == b[key]:
#         print((key, value))
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#542. Дано три словники, в яких ключами є малі букви латинського алфавіту, а значеннями - цілі числа.
# Ключі у всіх словниках – різні, їх є по 3 в кожному словнику. Об’єднайте всі три словники в один і виведіть його вміст.
# Підказка. скористайтеся оператором **, що використовується для об’єднання довільної кількості словників (Python 3.5+).
# dict1 = {
#     'x': 1,
#     'y': 2,
#     'z': 3
# }
# dict2 = {
#     'w': 10,
#     'f': 11,
#     'g': 2
# }
# dict3 = {
#     'n': 10,
#     'm': 11,
#     'e': 2
# }
#
# print({** dict1, ** dict2, ** dict3})
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#543. Напишіть програму для обчислення частоти слів у введеному рядку. Виведення має бути у порядку, що зворотний буквенно-цифровому порядку.
# s = 'The five boxing wizards jump quickly'
# lst = s.split()
# lst.sort(reverse=True)
# some_dict = {}
#
# for word in lst:
#     if word not in some_dict:
#         some_dict[word] = 1
#     else:
#         some_dict[word] += 1
#
# for word, num in some_dict.items():
#     print(f'{word}: {num}')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#544. Напишіть програму, яка підраховує і роздруковує кількість появ кожного символу у введеному рядку.
# s = 'abcabcdfghj'
# some_dict = {}
#
# for i in s:
#     if i not in some_dict:
#         some_dict[i] = 1
#     else:
#         some_dict[i] += 1
#
# for k, v in some_dict.items():
#     print(f'{k}, {v}')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#545. Створіть словник, який відображає ідентифікатори акцій на біржі.
# Ключами словника є ідентифікатори акцій, а значеннями - дійсні числа - ціни акцій.
# Надрукуйте ціни акцій для мінімального і максимального значення ціни відповідно та їх ідентифікатори.
# shares = {
#     'BTC': 610.5,
#     'FB': 10.75,
#     'AAP': 154.2,
#     'PLKK': 536.7,
#     'AAPL': 612.78
# }
#
# new_dict = {}
# for key, value in shares.items():
#     new_dict[value] = key
#
# print(min(list(new_dict)), new_dict[min(list(new_dict))])
# print(max(list(new_dict)), new_dict[max(list(new_dict))])
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#546. Створіть словник, який відображає ідентифікатори акцій на біржі.
# Ключами словника є ідентифікатори акцій, а значеннями - дійсні числа - ціни акцій.
# Надрукуйте ціни акцій та ідентифікатори у порядку зростання ціни.
# first_dict = {
#     'IBM': 205.55,
#     'ACME': 45.23,
#     'AAPL': 612.78,
#     'HPQ': 37.2,
#     'FB': 10.75
# }
#
# second_dict = {}
# for k, v in first_dict.items():
#     second_dict[v] = k
#
# for k, v in sorted(second_dict.items()):
#     print(k, v)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#547. Створіть словник, який відображає ідентифікатори акцій на біржі. Ключами словника є ідентифікатори акцій,
# а значеннями - дійсні числа - ціни акцій. На основі цього словника створіть програмно словник,
# який містить значення цін акцій, які більше якогось введеного цілого значення n, і виведіть елементи другого словника.
# first_dict = {
#     'IBM': 205.55,
#     'ACME': 45.23,
#     'AAPL': 612.78,
#     'HPQ': 37.2,
#     'FB': 10.75
# }
# second_dict = {}
#
# for k, v in first_dict.items():
#     if v >= 200:
#         second_dict[k] = v
#
# for k, v in second_dict.items():
#     print(k, v)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#548. Створіть словник, який відображає ідентифікатори акцій на біржі.
# Ключами словника є ідентифікатори акцій, а значеннями - дійсні числа - ціни акцій.
# На основі цього словника створіть програмно словник із значеннями акцій технологічних компаній.
# first_dict = {
#     'IBM': 205.55,
#     'ACME': 45.23,
#     'AAPL': 612.78,
#     'HPQ': 37.2,
#     'FB': 10.75
# }
# tech_companies = ['AAPL', 'IBM', 'HPQ']
#
# second_dict = {}
# for k, v in first_dict.items():
#     if k in tech_companes:
#         second_dict[k] = v
#
# for k, v in second_dict.items():
#     print(k, v)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#549. В рядку записаний текст. Словом вважається послідовність непробільних символів, які йдуть підряд,
# слова розділені одним або більшим числом пропуском або символами кінця рядка.
# Для кожного слова з цього тексту підрахуйте, скільки разів воно зустрічалося в цьому тексті раніше.
#
# text = 'var list set tuple list tuple tuple dict var'
# words = text.split()
# word_count = {}
# result = []
#
# for word in words:
#     result.append(word_count.get(word, 0))
#     word_count[word] = word_count.get(word, 0) + 1
# print(*result)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#550. Напишіть програму для сортування за зростанням словника за значеннями.
# Словник зберігає пари ключ-значення у вигляді «країна: столиця». Інформація виводиться як у вихідних даних:
# сортування має бути проведено за назвами столиць.
# Примітка. При використанні метода sorted, можна застосувати як ключ лямбда-функцію на зразок key=lambda x: x[1].
# country_capital_dict = {
#     'Ukraine': 'Kyiv',
#     'France': 'Paris',
#     'China': 'Beijing',
#     'Canada': 'Ottawa',
#     'Denmark': 'Copenhagen'
# }
# sort_capital_country = sorted(country_capital_dict.items(), key=lambda item:item[1])
# print(sort_capital_country)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#551. Напишіть програму для сортування за спаданням словника за значеннями.
# Словник зберігає пари ключ-значення у вигляді «країна: столиця». Інформація виводиться як у вихідних даних:
# сортування має бути проведено за назвами столиць у порядку, протилежному алфавітному.
# Примітка. При використанні метода sorted, можна застосувати як ключ лямбда-функцію на зразок key=lambda x: x[1].
# country_capital_dict = {
#     'Ukraine': 'Kyiv',
#     'France': 'Paris',
#     'China': 'Beijing',
#     'Canada': 'Ottawa',
#     'Denmark': 'Copenhagen'
# }
#
# sort_capital_country_revers = sorted(country_capital_dict.items(), key=lambda item:item[1], reverse=True)
# print(sort_capital_country_revers)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#552. Дано словник, у якому ключами є назви 10 карпатських вершин, а значеннями - їх висота у метрах. Елементи у словнику невпорядковані.
# Напишіть програму для виведення висоти трьох найвищих гір. Примітка. При використанні метода sorted, можна застосувати як ключ лямбда-функцію на зразок key=lambda x: x[1].
# ua_mountain_peaks = {
#     'Сивуля Велика': 1836,
#     'Піп Іван Мармароський': 1936,
#     'Піп Іван Чорногірський': 2028,
#     'Менчул': 1998,
#     'Шпиці': 1863,
#     'Бребенескул': 2035,
#     'Ребра': 2001,
#     'Говерла': 2061,
#     'Гутин Томнатик': 2016,
#     'Петрос': 2020
# }
#
# sort_ua_mountain_peaks = sorted(ua_mountain_peaks.items(), key=lambda item:item[1], reverse=True)
#
# for peak in sort_ua_mountain_peaks[:3]:
#     print(f'{peak[0]}: {peak[1]} м.')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#553. Дано словник, в якому ключами назви країн-чемпіонів світу з футболу, а значеннями - список років, в які вони ставали чемпіонами.
# Елементи у словнику і у списку невпорядковані. Напишіть програму для впорядкування значень років в алфавітному порядку і виведення словника.
# world_football_champ_countries = {
# 'Spain': [2010],
# 'Argentina': [1986, 1978],
# 'Italy': [2006, 1938, 1982, 1934],
# 'Uruguay': [1930, 1950],
# 'Brazil': [1994, 1958, 2002, 1970, 1962],
# 'France': [2018, 1998],
# 'England': [1966],
# 'Germany': [1990, 2014, 1974, 1954]
# }
#
# sort_country_dict = dict(sorted(world_football_champ_countries.items()))
#
# for country, years in sort_country_dict.items():
#     years.sort()
# print(sort_country_dict)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#554. Дано словник, в якому ключами є ідентифікатори абітурієнтів у форматі S x: літера S, пропуски, x - порядковий номер абітурієнта,
# а значеннями - список назв навчальних предметів, з яких абітурієнт буде здавати екзамен.
# Напишіть програму для друку створеного словника і словника, в якому видалені пропуски із ключів.
# students = {
#     'S  001': ['Math', 'Computer Science'],
#     'S   002': ['Math', 'English'],
#     'S   003': ['Philosophy', 'English', 'Physical training']
# }
# print(students)
#
# new_students = {}
# for student, subject in students.items():
#     s = ''
#     for i in student.split():
#         s += i
#     new_students[s] = subject
# print(new_students)
#
#
# new_students_new = {}
# for student, subject in students.items():
#     n = student.replace(' ', '')
#     new_students_new[n] = subject
# print(new_students_new)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#555.Дано словник, у якому ключами є назви фруктів, а значеннями - список значень у вигляді [Білки (г), Жири (г), Вуглеводи (г), Ккал/100 г].
# Елементи у словнику невпорядковані. Напишіть програму для виведення номера елемента, ключа і значення елемента у словнику як у вихідних даних.
# fruits = {
#     'Apricots': [0.9, 0, 10.5, 46],
#     'Grape': [0.4, 0, 17.5, 69],
#     'Orange': [0.9, 0, 8.4, 38],
#     'Ananas': [0.4, 0, 11.8, 48],
#     'Apples': [0.4, 0, 11.3, 46],
#     'Pear': [0.4, 0, 10.7, 42],
#     'Kiwi': [0.8, 0, 8.1, 47]
# }
# num = 1
#
# for fruit, values in fruits.items():
#     lst = []
#     for i in values:
#         lst.append(str(i))
#     g = ' '.join(lst)
#     print('{} {:<10s} {}'.format(num, fruit, g))
#     num += 1

#***************OR like this*********************
# fruits = {
#     'Apricots': [0.9, 0, 10.5, 46],
#     'Grape': [0.4, 0, 17.5, 69],
#     'Orange': [0.9, 0, 8.4, 38],
#     'Ananas': [0.4, 0, 11.8, 48],
#     'Apples': [0.4, 0, 11.3, 46],
#     'Pear': [0.4, 0, 10.7, 42],
#     'Kiwi': [0.8, 0, 8.1, 47]
# }
# num = 1
#
# for fruit, values in fruits.items():
#     print('{} {:<10} {} {} {:<4} {}'.format(num, fruit, *values))
#     num += 1
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#556. Дано словник, що складається з пар слів. Кожне слово є синонімом до парного йому слова.
# Всі слова в словнику різні. Для даного слова визначте його синонім. Програма отримує на вхід кількість пар синонімів n.
# Далі йде n рядків, кожен рядок містить рівно два слова-синоніми. Після цього вводиться одне слово.
# Програма повинна вивести синонім до даного слова.
# num = int(input(': '))
# n = 0
# some_dict = {}
#
# while n < num:
#     words = input('Enter: ')
#     word = words.split()
#     some_dict[word[0]] = word[1]
#     n += 1
# print(some_dict)
#
# word_synonym = input('synonym of the word: ')
#
# for k, v in some_dict.items():
#     if k.lower() == word_synonym.lower():
#         print(v)
#         break
#     elif v.lower() == word_synonym.lower():
#         print(k)
#         break
# else:
#     print('there is no such word...')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#557. У вхідному рядку записана послідовність чисел через пропуск. Для кожного числа виведіть слово YES (в окремому рядку),
# якщо це число раніше зустрічалося в послідовності або NO, якщо не зустрічалося.
# Вводиться список чисел. Всі числа списку знаходяться на одному рядку. Для зберігання значень використайте словник.
# s = '4 6 1 8 4 9 0 1'
# numbers = map(int, s.split())
# count_keys = 0
# lst_for_result = []
# dict_for_result = {}
#
# for num in numbers:
#     if num in lst_for_result:
#         dict_for_result[count_keys] = 'YES'
#     else:
#         dict_for_result[count_keys] = 'NO'
#
#     lst_for_result.append(num)
#     print(dict_for_result[count_keys])
#     count_keys += 1
#
#************OR LIKE THIS******************
# s = '4 6 1 8 4 9 0 1'
# numbers = map(int, s.split())
# dict_for_result = {}
#
# for num in numbers:
#     if num in dict_for_result:
#         print('YES')
#     else:
#         print('NO')
#         dict_for_result[num] = True
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#558.Вводиться кількість слів у словнику. Словник складається з пар слів. Кожне слово є синонімом іншого слова.
# Всі слова в словнику різні. Після введення словника вводиться ще одне слово. Знайти синонім для нього.
# num = int(input(': '))
# n = 0
# some_dict = {}
#
# while n < num:
#     words = input('Enter: ')
#     word = words.split()
#     some_dict[word[0]] = word[1]
#     n += 1
#
# word_synonym = input('synonym of the word: ')
#
# for k, v in some_dict.items():
#     if k.lower() == word_synonym.lower():
#         print(v)
#         break
#     elif v.lower() == word_synonym.lower():
#         print(k)
#         break
# else:
#     print('there is no such word...')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#559. На вхід програми подається послідовність чисел від 1 до 9, що закінчується нулем. Всього буде введено не більше 100000 чисел.
# Підрахуйте в цій послідовності кількість одиниць, кількість двійок, кількість трійок і т. д. і надрукуйте результат.
# У вихідних даних завжди має бути 9 чисел.
# s = '1 1 4 1 5 8 6 3 5 1 0'
# s_lst = list(map(int, s.split()))
# dict_for_result = {}
#
# for i in range(1, 10):
#     value = s_lst.count(i)
#     dict_for_result[i] = value
#
# print(*dict_for_result.values())
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#560. Дано текст англійською мовою. Крім англійських букв, в ньому можуть зустрічатися пропуски і розділові знаки.
# Надрукуйте відомості про те, скільки яких букв зустрічається в цьому тексті (вивести 26 чисел).
# При підрахунку великі та малі літери не розрізняються.
# s = 'Hello world!'
# dict_for_result = {}
#
# for letter in range(ord('a'), ord('z')+1):
#     dict_for_result[chr(letter)] = 0
#
# for letter in list(s.lower()):
#     if letter in dict_for_result:
#         dict_for_result[letter] += 1
# print(*dict_for_result.values())
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#561. Потрібно написати програму, яка здійснює перетворення з однієї одиниці вимірювання довжини в інші. Повинні підтримуватись
#       милі (1 mile = 1609 m)
#       ярди (1 yard = 0.9144 m)
#       фути (1 foot = 30.48 cm)
#       дюйми (1 inch = 2.54 cm)
#       кілометри (1 km = 1000 m)
#       метри (m)
#       сантиметри (1 cm = 0.01 m)
#       міліметри (1 mm = 0.001 m)
# Використовуйте саме зазначені в формулюванні завдання одиниці виміру з вказаною точністю. Вводиться один рядок з фразою такого виду
#       <number> <unit_from> in <unit_to>
# Програма має вивести дробове число в експоненційному форматі, з точністю рівно два знаки після десяткової крапки.
# units_of_measurement = {
#     'mile': 1609,
#     'yard': 0.9144,
#     'foot': 30.48,
#     'inch': 2.54,
#     'km': 1000,
#     'm': 1,
#     'cm': 0.01,
#     'mm': 0.001
# }
# s = '15.5 mile in inch'
#
# if s.split()[1] == 'foot' or s.split()[-1] == 'foot' or s.split()[1] == 'inch' or s.split()[-1] == 'inch':
#     units_of_measurement['foot'] = units_of_measurement['foot'] / 100
#     units_of_measurement['inch'] = units_of_measurement['inch'] / 100
#
# result = float(s.split()[0]) * units_of_measurement[s.split()[1]] / units_of_measurement[s.split()[-1]]
#
# print('{:.2e}'.format(result))
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#562. Напишіть програму, яка приймає послідовність чисел і визначає, чи всі числа відрізняються один від одного чи ні. Використовувати цикли не можна.
# lst = [1, 4, 5, 0, 2]
# if len(lst) == len(set(lst)):
#     print('is unique sequence')
# else:
#     print('duplicate list')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#563. Вводиться текст в одному рядку. Для кожного слова тексту підрахуйте кількість його входжень перед ним.
# s = 'one two one two three two four three'
# word_lst = s.split()
# some_dict = {}
# lst = []
#
# for word in word_lst:
#     lst.append(some_dict.get(word, 0))
#     some_dict[word] = some_dict.get(word, 0) + 1
#
# print(*lst)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#564. Вводяться n рядків зі скороченими назвами країн і повними назвами міст кожної країни, після цього вводяться m рядків з назвами міст.
# Напишіть програму, яка для кожного міста друкує скорочену назву країну, в якій місто знаходиться.
# country_city = {
#     'UA': ['Kyiv', 'Zhytomyr', 'Ternopil', 'Dnipro'],
#     'JP': ['Tokyo', 'Osaka', 'Kyoto'],
#     'CA': ['Montreal', 'Toronto', 'Ottawa'],
#     'USA': ['Boston', 'Pittsburgh', 'Washington', 'Seattle'],
#     'UK': ['London', 'Edinburgh', 'Cardiff', 'Belfast']
# }
#
# city_in = input('Enter: ')
#
# for country, city in country_city.items():
#     if city_in in city:
#         print(country)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#565. У першому рядку вводиться кількість рядків, потім задаються самі рядки слів, розділених пропусками. Виведіть слово,
# яке у рядках зустрічається найчастіше. Якщо таких слів декілька, надрукуйте те, що розміщується вище в алфавітному порядку.
# num = int(input('number: '))
# lst = []
# count = 0
# some_dict ={}
# result = []
#
# while count < num:
#     s = input('Enter words: ')
#     lst.extend(s.split())
#     count += 1
#
# for word in lst:
#     if word in some_dict:
#         some_dict[word] += 1
#     else:
#         some_dict[word] = 1
#
#
# for k,v in some_dict.items():
#     if v == max(some_dict.values()):
#         result.append(k)
# print(sorted(result)[0])
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#566. Напишіть програму для підрахунку повторюваних символів у введеному рядк
# s = 'the quick brown fox jumps over the lazy dog'
# result_dict = {}
#
# for i in list(s):
#     if i in result_dict:
#         result_dict[i] += 1
#     else:
#         result_dict[i] = 1
#
# for k, v in result_dict.items():
#     if v > 1:
#         print(k, v)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#567. Дано дві послідовності цілих чисел. Надрукуйте числа, які присутні в обох послідовностях.
# first_set = {1, 5, 8, 0, 2, 9}
# second_set = {8, 3, 6, 7, 1}
#
# print(*first_set & second_set)
# print(*first_set.intersection(second_set))
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#568.Дано дві послідовності цілих чисел. Надрукуйте нову послідовність, яка об’єднує числа, що присутні в обох послідовностях, без дублікатів.
# first_set = {1, 5, 8, 0, 2, 9}
# second_set = {8, 3, 6, 7, 1}
#
# print(*first_set | second_set)
# print(*first_set.union(second_set))
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#569. Дано список значень різних типів даних. Створіть словник із значеннями списку як ключами, і назвами відповідного типу даних як значеннями словника.
# У словнику можуть бути присутні дані одного типу. Надрукуйте вміст словника як у вихідних даних.
# lst = [1952, 2+3j, {'Class C': ['Volkswagen Golf', 'Ford Focus'], 'Class F': ['Audi A8', 'Bentley', 'Maybach'], 'E': ['Toyota Camry']}, None, 1000000,
#        10.45, False, 'pythonguide.pp.ua', 5.5, (1, -6), {}, [3, 15]]
# result_dict = {}
#
# for i in lst:
#     if type(i) in result_dict:
#         result_dict[type(i)] += [i]
#     else:
#         result_dict[type(i)] = [i]
#
# for k, v in result_dict.items():
#     print(k, *v)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#570. Дано послідовність цілих чисел. Для кожного числа надрукуйте слово YES (в окремому рядку), якщо це число вже зустрічалось в послідовності,
# і надрукуйте NO, якщо воно ще не було виявлено. Для зберігання значень використайте множину
# lst = [1, 4, 5, 2, 10, 15, 4, 10, 3]
# m = set()
#
# for i in lst:
#     if i not in m:
#         print('NO')
#     else:
#         print('YES')
#
#     m.add(i)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#571. Напишіть програму, яка зможе підрахувати слова у введеному рядку, розділені пропуском і вивести отриману статистику:
# для кожного унікального слова обчислити число його повторень (без урахування регістру),
# слова не повинні повторюватися, порядок слів довільний.
# s = 'a bb acD bb abc ac BCD a'
# result_dict = {}
#
# for i in s.split():
#     if i.lower() not in result_dict:
#         result_dict[i.lower()] = 1
#     else:
#         result_dict[i.lower()] += 1
#
# for k, v in result_dict.items():
#     print(k, v)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#572. Напишіть програму, яка приймає на вхід список ігор футбольних команд з результатом матчу і виводить зведену таблицю результатів всіх матчів.
# За перемогу команді нараховується 3 очки,
# за поразку - 0,
# за нічию - 1.
# Формат введення наступний:
# у першому рядку вказано ціле число n - кількість завершених ігор.
# Після цього йде n рядків, в яких записані результати гри в наступному форматі:
#   1_команда;забито_1_командою;2_команда;забито_2_командою
#Результати виведення програми необхідно оформити наступним чином:
#   Команда: Всього_ігор Перемог Нічиїх Поразок Всього_очок
# приклад введення-виведення наведено у вхідних і вихідних даних. Порядок виведення команд довільний.
#Вхідні дані:
    # 4
    # Ukraine;2;France;1
    # Italy;1;Germany;3
    # France;0;Italy;0
    # Germany;2;Ukraine;0
#Вихідні дані:
# Ukraine: 2 1 0 1 3
# France: 2 0 1 1 1
# Italy: 2 0 1 1 1
# Germany: 2 2 0 0 6
#
# num = int(input("how many games: "))
# game_lst = []
# count = 0
#
# #        we convert the input data into dictionaries for each game and combine them into a list
# while count < num:
#     game_resume = input('game_resume: ')
#     s = game_resume.split(';')
#     game_resume_dict = {}
#     game_resume_dict[s[0]] = int(s[1])
#     game_resume_dict[s[2]] = int(s[3])
#     game_lst.append(game_resume_dict)
#     count += 1
#
# #       we create a dictionary of dictionaries to store data about each team
# dict_for_result = {}
# for i in game_lst:
#     for w in i:
#         if w not in dict_for_result:
#             dict_for_result[w] = {'total_games': 0, 'win': 0, 'draw': 0, 'lose': 0, 'total_score': 0}
#
# #      total_games & win & draw & lose & total_score
# for i in game_lst:
#     for w in i:
#         if w in dict_for_result:
#             dict_for_result[w]['total_games'] += 1
#
#     country = list(i.keys())
#     if i[country[0]] > i[country[1]]:
#         dict_for_result[country[0]]['win'] += 1
#         dict_for_result[country[1]]['lose'] += 1
#         dict_for_result[country[0]]['total_score'] += 3
#     elif i[country[0]] < i[country[1]]:
#         dict_for_result[country[1]]['win'] += 1
#         dict_for_result[country[0]]['lose'] += 1
#         dict_for_result[country[1]]['total_score'] += 3
#     elif i[country[0]] == i[country[1]]:
#         dict_for_result[country[0]]['draw'] += 1
#         dict_for_result[country[1]]['draw'] += 1
#         dict_for_result[country[0]]['total_score'] += 1
#         dict_for_result[country[1]]['total_score'] += 1
#
# print('{:^10}|{:^5}|{:^3}|{:^4}|{:^4}|{:^5}'.format('country', 'games', 'win', 'draw', 'lose', 'score'))
# print('------------------------------------')
# for k, v in dict_for_result.items():
#     print('{:<10}|{:^5}|{:^3}|{:^4}|{:^4}|{:^5}' .format(k, v['total_games'], v['win'], v['draw'], v['lose'], v['total_score']))
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#573. Дано два списки чисел. Знайдіть всі числа, що зустрічаються як в першому, так і другому списках, і надрукуйте їх у порядку зростання.
# f_lst = [2, 5, 8, 11, 10, 9]
# s_lst = [11, 3, 7, 6, 8, 5]
#
# print(*sorted(set(f_lst) & set(s_lst)))
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#574.Напишіть програму, яка вміє шифрувати і розшифровувати використовуючи шифр підстановки.
# Програма приймає на вхід два рядки однакової довжини, у першому рядку записані символи початкового алфавіту,
# у другому рядку - символи кінцевого алфавіту (шифр підстановки), після чого йде рядок, який потрібно зашифрувати переданим шифром підстановки,
# і ще один рядок, який потрібно розшифрувати. Нехай, наприклад, на вхід програми передано:
#     abcd
#     *d%#
#     abacabadaba
#     #*%*d*%
#Це означає, що символ a вхідного повідомлення замінюється на символ * в шифрі, b замінюється на d, c - на % і d - на #.
# Потрібно зашифрувати рядок abacabadaba і розшифрувати рядок #*%*d*% за допомогою цього шифру.
# Отримуємо наступні рядки, які і передаємо на виведення програми:
#     *d*%*d*#*d*
#     dacabac
# Вхідні дані:
#     abcd
#     1234
#     ababcdcd
#     44332211
# Вихідні дані:
#     12123434
#     ddccbbaa
#
# initial_alphabet = 'abcd'
# final_alphabet = '1234'
# to_encrypt = 'ababcdcd'
# to_decipher = '44332211'
#
# some_dict = {}
# c = 0
# for i in  initial_alphabet:
#     some_dict[i] = final_alphabet[c]
#     c += 1
#
# final_encrypt = []
# for i in to_encrypt:
#     if i in some_dict:
#         final_encrypt.append(some_dict[i])
# f_e = ''.join(final_encrypt)
# print(f_e)
#
# some_dict_to_decipher = {}
# for k, v in some_dict.items():
#     some_dict_to_decipher[v] = k
# final_decipher = []
# for i in to_decipher:
#     if i in some_dict_to_decipher:
#         final_decipher.append(some_dict_to_decipher[i])
# f_d = ''.join(final_decipher)
# print(f_d)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#575. Дано ціле число n, за яким слідують n рядків тексту. Надрукуйте кількість різних слів, які з’являються у тексті.
# Для цього ми визначаємо, що слово - це послідовність символів, що не містить пропусків. Слова розділені одним або
# декількома пропусками або символами нового рядка. Знаки пунктуації є частиною слова в цьому визначенні.
# num = int(input('How many strings? - '))
# big_s = ''
# counting = 0
#
# while counting < num:
#     s = input('Enter: ')
#     big_s += ' ' + s
#     counting += 1
#
# print(len(set(big_s.split())))
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#576. Дано список цілих чисел, який може містити до 100000 чисел. Визначте, скільки в ньому зустрічається різних чисел.
# lst = [2, 5, 7, 7, 9, 0, 3, 4]
# print(len(set(lst)))
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#577. Дано послідовність слів, розділених комами. Надрукуйте унікальні слова у лексикографічному порядку як у вихідних даних.
# s = 'abc,abc,bac,aca'
# a = sorted(set(s.split(',')))
# g = ','.join(a)
# print(g)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#578. Напишіть програму для пошуку загальних елементів з двох введених рядків слів.
# a = 'Red Green Orange White'
# b = 'Black Green White Pink'
#
# print(set(a.split()) & set(b.split()))
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#580. Дано дві послідовності цілих чисел. Необхідно надрукувати обидві послідовності з числами, які відсутні в іншій послідовності.
# a = [1, 3, 4, 5, 8, 9, 12]
# b = [3, 4, 7, 8, 12]
#
# print(*(set(a) - set(b)))
# print(*(set(b) - set(a)))
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#581. Дано рядок тексту, в якому слова розділені пррпусками. Надрукуйте всі слова, які зустрічаються в тексті, та їхні частоти як у вихідних даних.
# s = 'one two three one four five seven ten seven one'
# some_dict = {}
# lst = []
#
# for i in s.split():
#     if i not in some_dict:
#         some_dict[i] = 1
#     else:
#         some_dict[i] += 1
#
# for k, v in some_dict.items():
#     lst.append((k, v))
#
# print(*lst)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#582. Дано два списки чисел, які можуть містити до 100000 чисел кожен. Порахуйте, скільки чисел міститься одночасно як в першому списку, так і в другому списках.
# Вводяться два списки цілих чисел. Всі числа кожного списку знаходяться на окремому рядку.
# a = [3, 5, 8]
# b = [5, 2, 3]
#
# print(len(set(a) & set(b)))
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#583. Дано два списки чисел, які можуть містити до 10000 чисел кожен. Виведіть всі числа, які входять як в перший, так і в другий список в порядку зростання.
# Вводяться два списки цілих чисел. Всі числа кожного списку знаходяться на окремому рядку.
# a = [4, 6, 8, 9]
# b = [1, 9, 3, 6]
#
# print(*sorted(set(a) & set(b)))
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#584. Напишіть програму, яка приймає на вхід список цілих чисел, розділених пропуском, і виводить на екран значення,
# які повторюються в ньому більш ніж один раз. При виведенні числа не повинні повторюватися, порядок виведення може бути довільним.
# lst = [4, 6, 10, 14, 6, 9, 10, 11]
# some_dict = {}
# result = []
#
# for i in lst:
#     if i not in some_dict:
#         some_dict[i] = 1
#     else:
#         some_dict[i] += 1
#
# for k, v in some_dict.items():
#     if v > 1:
#         result.append(k)
#
# print(*result)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#585. Дано рядок слів, розділених пропусками. Надрукуйте довжину найдовшого слова.
# s = 'aaa aaaaa aa a aaaaa'
# result = 0
#
# for i in s.split():
#     if len(i) > result:
#         result = len(i)
#
# print(result)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#586. Дано список країн і міст кожної країни. Потім подані назви міст. Для кожного міста вкажіть, в якій країні воно знаходиться.
# Програма отримує на вхід кількість країн n. Далі йде n рядків, кожен рядок починається з назви країни, потім йдуть назви міст цієї країни.
# У наступному рядку записано число m, далі йдуть m запитів - назви якихось m міст, перерахованих вище.
# Для кожного із запиту виведіть назву країни, в якій знаходиться дане місто.
# num_of_lst = int(input('Enter: '))
# count_for_lst = 0
# country_city = {}
#
# while count_for_lst < num_of_lst:
#     s = input('enter: ').split()
#     country_city[s[0]] = s[1:]
#     count_for_lst += 1
# print(country_city)
#
# count_for_city = int(input('Enter: '))
# count_for_request = 0
#
# while count_for_request < count_for_city:
#     s = input('City: ')
#     for country, city in country_city.items():
#         if s in city:
#             print(country)
#
#     count_for_request += 1
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#587. Користувачем вводяться наступні дані: у першому рядку міститься кількість рядків n, а потім - вводяться n рядків слів.
# Надрукуйте слово, яке в тексті зустрічається найчастіше. Якщо таких слів є декілька, надрукуйте слово, яке в алфавітному порядку розташоване раніше.
# num = int(input('How many strings? - '))
#
# str_count = 0
# dict_for_lst = {}
# while str_count < num:
#     s = input('Enter: ').split()
#
#     for word in s:
#         if word not in dict_for_lst:
#             dict_for_lst[word] = 1
#         else:
#             dict_for_lst[word] += 1
#
#     str_count += 1
#
# result = []
# for word, count in dict_for_lst.items():
#     if count == max(dict_for_lst.values()):
#         result.append(word)
#
# print(sorted(result)[0])
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#588. Напишіть програму, яка виводить число в стилі LCD-калькулятора. На вхід програми подається послідовність цифр,
# яку потрібно вивести на екран в спеціальному стилі. Розмір всіх цифр 4 символу в ширину і 7 символів у висоту.
# Між цифрами повинен бути один порожній стовпець. Перед першою цифрою не повинно бути пропусків.
# Виведені цифри повинні бути обведені рамочкою, в кутах якої знаходиться символ x, горизонтальна лінія створюється з символу -,
# а вертикальна - з символу вертикальної риски |. Користувач вводить рядок - послідовність цифр,
# а програма має вивести 9 рядків, що містять цифри, записані в зазначеному форматі.
#
# lcd_num = {
#     0: {'a': ' -- ',
#         'b': '|  |',
#         'c': '|  |',
#         'd': '    ',
#         'e': '|  |',
#         'f': '|  |',
#         'g': ' -- '},
#     1: {'a': '    ',
#         'b': '   |',
#         'c': '   |',
#         'd': '    ',
#         'e': '   |',
#         'f': '   |',
#         'g': '    '},
#     2: {'a': ' -- ',
#         'b': '   |',
#         'c': '   |',
#         'd': ' -- ',
#         'e': '|   ',
#         'f': '|   ',
#         'g': ' -- '},
#     3: {'a': ' -- ',
#         'b': '   |',
#         'c': '   |',
#         'd': ' -- ',
#         'e': '   |',
#         'f': '   |',
#         'g': ' -- '},
#     4: {'a': '    ',
#         'b': '|  |',
#         'c': '|  |',
#         'd': ' -- ',
#         'e': '   |',
#         'f': '   |',
#         'g': '    '},
#     5: {'a': ' -- ',
#         'b': '|   ',
#         'c': '|   ',
#         'd': ' -- ',
#         'e': '   |',
#         'f': '   |',
#         'g': ' -- '},
#     6: {'a': ' -- ',
#         'b': '|   ',
#         'c': '|   ',
#         'd': ' -- ',
#         'e': '|  |',
#         'f': '|  |',
#         'g': ' -- '},
#     7: {'a': ' -- ',
#         'b': '   |',
#         'c': '   |',
#         'd': '    ',
#         'e': '   |',
#         'f': '   |',
#         'g': '    '},
#     8: {'a': ' -- ',
#         'b': '|  |',
#         'c': '|  |',
#         'd': ' -- ',
#         'e': '|  |',
#         'f': '|  |',
#         'g': ' -- '},
#     9: {'a': ' -- ',
#         'b': '|  |',
#         'c': '|  |',
#         'd': ' -- ',
#         'e': '   |',
#         'f': '   |',
#         'g': ' -- '}
# }
#
# a = []
# b = []
# c = []
# d = []
# e = []
# f = []
# g = []
#
# numbers = [0, 1, 2, 3, 4]
# for num in numbers:
#     if num in lcd_num:
#         a.append(lcd_num[num]['a'] )
#         b.append(lcd_num[num]['b'] )
#         c.append(lcd_num[num]['c'])
#         d.append(lcd_num[num]['d'])
#         e.append(lcd_num[num]['e'])
#         f.append(lcd_num[num]['f'])
#         g.append(lcd_num[num]['g'])
#
# stricks = len(numbers) * 4 + len(numbers)
#
# print('X', '-' * stricks, 'X')
# print('|',*a,' |')
# print('|',*b,' |')
# print('|',*c,' |')
# print('|',*d,' |')
# print('|',*e,' |')
# print('|',*f,' |')
# print('|',*g,' |')
# print('X', '-' * stricks, 'X')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#589. Комп’ютерний вірус атакував файлову систему суперкомп’ютера і пошкодив контроль прав доступу до файлів.
# Для кожного файлу є відомий набір операцій, які можуть бути застосовані до нього:
# писати (W),
# читати (R),
# виконати (X).
# Перший рядок містить число n - кількість файлів, що містяться у файловій системі.
# Наступні n рядків містять імена файлів і дозволені операції з ними, розділені пропусками.
# Наступний рядок містить ціле число m - кількість операцій з файлами. В наступних m рядках записані операції, які виконуються над файлами.
# До одного файлу можна звертатися багато разів. Для кожного запиту програма повинна надрукувати OK, якщо запитана операція з файлом є можливою,
# або Access denied, якщо операцію виконати неможливо.
# num_of_allowed_operations = int(input('How many allowed operations? - '))
# allowed_operations = {}
#
# for _ in range(num_of_allowed_operations):
#     operation = input('Enter an operation: ').split()
#     allowed_operations[operation[0]] = {}
#
#     for i in operation[1:]:
#         if i == 'W':
#             allowed_operations[operation[0]][i] = 'write'
#         elif i == 'R':
#             allowed_operations[operation[0]][i] = 'read'
#         elif i == 'X':
#             allowed_operations[operation[0]][i] = 'execute'
#
# print(allowed_operations)
#
# num_of_operations = int(input('How many operationes do you wont? - '))
# for _ in range(num_of_operations):
#     operation = input('Enter an operation: ').split()
#
#     if operation[0] in allowed_operations[operation[1]].values():
#         print('OK')
#     else:
#         print('Access denied')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#590. На шаховій дошці стоїть кінь. Відзначте положення коня на дошці і всі клітинки, які б’є кінь.
# Клітинку, де стоїть кінь, відзначте буквою K, клітинки, які б’є кінь, відзначте символами *, решта клітинок заповніть крапками.
# Програма отримує на вхід координати коня на шаховій дошці в шаховій нотації, тобто, у вигляді e2,
# де спочатку записується номер стовпця (буква від a до h, зліва направо), потім номер рядка (цифра від 1 до 8, знизу догори).
# Виведіть на екран зображення шахової дошки як у вихідних даних. abcdefgh
# chessboard = {
#     8: {'a': '.', 'b': '.', 'c': '.', 'd': '.', 'e': '.', 'f': '.', 'g': '.', 'h': '.'},
#     7: {'a': '.', 'b': '.', 'c': '.', 'd': '.', 'e': '.', 'f': '.', 'g': '.', 'h': '.'},
#     6: {'a': '.', 'b': '.', 'c': '.', 'd': '.', 'e': '.', 'f': '.', 'g': '.', 'h': '.'},
#     5: {'a': '.', 'b': '.', 'c': '.', 'd': '.', 'e': '.', 'f': '.', 'g': '.', 'h': '.'},
#     4: {'a': '.', 'b': '.', 'c': '.', 'd': '.', 'e': '.', 'f': '.', 'g': '.', 'h': '.'},
#     3: {'a': '.', 'b': '.', 'c': '.', 'd': '.', 'e': '.', 'f': '.', 'g': '.', 'h': '.'},
#     2: {'a': '.', 'b': '.', 'c': '.', 'd': '.', 'e': '.', 'f': '.', 'g': '.', 'h': '.'},
#     1: {'a': '.', 'b': '.', 'c': '.', 'd': '.', 'e': '.', 'f': '.', 'g': '.', 'h': '.'}
# }
#
# horse = 'd5'
# print('__________________________________________________')
#
# chessboard[int(horse[1])+2][chr(ord(horse[0])-1)] = '*'
# chessboard[int(horse[1])+2][chr(ord(horse[0])+1)] = '*'
# chessboard[int(horse[1])+1][chr(ord(horse[0])-2)] = '*'
# chessboard[int(horse[1])+1][chr(ord(horse[0])+2)] = '*'
# chessboard[int(horse[1])][horse[0]] = 'K'
# chessboard[int(horse[1])-1][chr(ord(horse[0])-2)] = '*'
# chessboard[int(horse[1])-1][chr(ord(horse[0])+2)] = '*'
# chessboard[int(horse[1])-2][chr(ord(horse[0])+1)] = '*'
# chessboard[int(horse[1])-2][chr(ord(horse[0])-1)] = '*'
#
# for k, v in chessboard.items():
#     print(*v.values())
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#591. На шаховій дошці стоїть ферзь. Відзначте положення ферзя на дошці і всі клітинки, які б’є ферзь.
# Клітинку, де стоїть ферзь, відзначте буквою Q, клітинки, які б’є ферзь, відзначте символами *,
# решта клітинок заповніть крапками. Програма отримує на вхід координати ферзя на шаховій дошці в шаховій нотації, тобто,
# у вигляді e2, де спочатку записується номер стовпця (буква від a до h, зліва направо), потім номер рядка (цифра від 1 до 8, знизу догори).
# Виведіть на екран зображення шахової дошки як у вихідних даних.
# queen = 'f3'
# chessboard = {}
#
# #     create a clean chessboard
# for col in range(8, 0, -1):
#     chessboard[col] = {}
#     for row in range(ord('a'), ord('h')+1):
#         chessboard[col][chr(row)] = '.'
#
# #     mark horizontal and vertical moves
# for k, v in chessboard.items():
#     if k == int(queen[1]):
#         for n, m in v.items():
#             chessboard[k][n] = '*'
#
#     for m, n in v.items():
#         if m == queen[0]:
#             chessboard[k][m] = '*'
#
# #      mark diagonal moves
# directoines = [(1, 1), (1, -1), (-1, 1), (-1, -1)]
# for dx, dy in directoines:
#     queen_x = ord(queen[0])
#     queen_y = int(queen[1])
#
#     while True:
#         queen_x += dx
#         queen_y += dy
#
#         if ord('a') <= queen_x < ord('i') and 1 <= queen_y < 9:
#             chessboard[queen_y][chr(queen_x)] = '*'
#         else:
#             break
#
# #       mark the queen
# chessboard[int(queen[1])][queen[0]] = 'Q'
#
# #       Output
# for k, v in chessboard.items():
#     print(*v.values())
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 592. На шаховій дошці стоїть слон. Відзначте положення слона на дошці і всі клітинки, які б’є слон. Клітинку, де стоїть слон,
# відзначте буквою B, клітинки, які б’є слон, відзначте символами *, решта клітинок заповніть крапками.
# Програма отримує на вхід координати слона на шаховій дошці в шаховій нотації, тобто, у вигляді e2,
# де спочатку записується номер стовпця (буква від a до h, зліва направо), потім номер рядка (цифра від 1 до 8, знизу догори).
# Виведіть на екран зображення шахової дошки як у вихідних даних.
#
# elephant = 'g4'
# chessboard = {}
#
#
# for col in range(8, 0, -1):
#     chessboard[col] = {}
#     for row in range(ord('a'), ord('h')+1):
#         chessboard[col][chr(row)] = '.'
#
# directoines = [(1, 1), (1, -1), (-1, 1), (-1, -1)]
# for dx, dy in directoines:
#     elephant_x = ord(elephant[0])
#     elephant_y = int(elephant[1])
#
#     while True:
#         elephant_x += dx
#         elephant_y += dy
#
#         if ord('a') <= elephant_x < ord('i') and 1 <= elephant_y < 9:
#             chessboard[elephant_y][chr(elephant_x)] = '*'
#         else:
#             break
#
# chessboard[int(elephant[1])][elephant[0]] = 'B'
#
# for k, v in chessboard.items():
#     print(*v.values())
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# На шаховій дошці стоїть тура. Зроби теж саме але для Тури
# tour = 'e2'
# chessboard = {}
#
#
# for col in range(8, 0, -1):
#     chessboard[col] = {}
#     for row in range(ord('a'), ord('h')+1):
#         chessboard[col][chr(row)] = '.'
#
# for k, v in chessboard.items():
#     if k == int(tour[1]):
#         for n, m in v.items():
#             chessboard[k][n] = '*'
#
#     for m, n in v.items():
#         if m == tour[0]:
#             chessboard[k][m] = '*'
#
# chessboard[int(tour[1])][tour[0]] = 'R'
#
# for k, v in chessboard.items():
#     print(*v.values())
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# На шаховій дошці стоїть король. Зроби теж саме але для Короля
# king = 'c5'
# chessboard = {}
#
#
# for col in range(8, 0, -1):
#     chessboard[col] = {}
#     for row in range(ord('a'), ord('h')+1):
#         chessboard[col][chr(row)] = '.'
#
#
# for k, v in chessboard.items():
#     if k == int(king[1]) + 1:
#         for row, vol in v.items():
#             if row == chr(ord(king[0]) - 1):
#                 chessboard[k][row] = '*'
#             elif row == king[0]:
#                 chessboard[k][row] = '*'
#             elif row == chr(ord(king[0]) + 1):
#                 chessboard[k][row] = '*'
#     elif k == int(king[1]):
#         for row, vol in v.items():
#             if row == chr(ord(king[0]) - 1):
#                 chessboard[k][row] = '*'
#             elif row == king[0]:
#                 chessboard[k][row] = '*'
#             elif row == chr(ord(king[0]) + 1):
#                 chessboard[k][row] = '*'
#     elif k == int(king[1]) - 1:
#         for row, vol in v.items():
#             if row == chr(ord(king[0]) - 1):
#                 chessboard[k][row] = '*'
#             elif row == king[0]:
#                 chessboard[k][row] = '*'
#             elif row == chr(ord(king[0]) + 1):
#                 chessboard[k][row] = '*'
#
#
# chessboard[int(king[1])][king[0]] = 'K'
#
# for k, v in chessboard.items():
#     print(*v.values())
#
# #-----------------------------OR---------------------------------------
#
#
# king = 'c5'
# chessboard = {}
#
#
# for col in range(8, 0, -1):
#     chessboard[col] = {}
#     for row in range(ord('a'), ord('h')+1):
#         chessboard[col][chr(row)] = '.'
#
# for dx in [-1, 0 , 1]:
#     for dy in [-1, 0, 1]:
#         king_x = ord(king[0]) + dx
#         king_y = int(king[1]) + dy
#
#         if ord('a') <= king_x < ord('i') and 1 <= king_y < 9:
#             chessboard[king_y][chr(king_x)] = '*'
#
#
# chessboard[int(king[1])][king[0]] = 'K'
#
# for k, v in chessboard.items():
#     print(*v.values())
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#595. Програма отримує на вхід координати певної клітинки на шаховій дошці в шаховій нотації, тобто, у вигляді e2,
# де спочатку записується номер стовпця (буква від a до h, зліва направо), потім номер рядка (цифра від 1 до 8, знизу догори).
# Виведіть на екран зображення шахової дошки, в якому вказаний колір клітинки: B (чорний колір) або W (білий колір).
#
# cell = 'b6'
# chessboard = {}
#
# for col in range(8, 0, -1):
#     chessboard[col] = {}
#
#     if col % 2 == 0:
#         for row in range(ord('a'), ord('i')):
#             m = (row + 1) % 2
#             if m == 0:
#                 chessboard[col][chr(row)] = 'W'
#             elif m == 1:
#                 chessboard[col][chr(row)] = 'B'
#     elif col % 2 == 1:
#         for row in range(ord('a'), ord('i')):
#             m = row % 2
#             if m == 0:
#                 chessboard[col][chr(row)] = 'W'
#             elif m == 1:
#                 chessboard[col][chr(row)] = 'B'
#
# for k, v in chessboard.items():
#     if k == int(cell[1]):
#         for a, b in v.items():
#             if a != cell[0]:
#                 chessboard[k][a] = '.'
#     elif k != int(cell[1]):
#         for a in v:
#             chessboard[k][a] = '.'
#
# for k, v in chessboard.items():
#     print(*v.values())
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#596. Двоє друзів вирішили здійснити влітку сходження в гори Карпати. Кожен з них зібрав свій рюкзак речей.
# Перевірте, які речі присутні в обох рюкзаках друзів, які є лише в першому рюкзаку, але не має в другому і, навпаки, є в другому і відсутні в першому.
# Дано два словники, у яких ключами є назви речей, а значеннями - кількості речей. Надрукуйте назви речей і їх кількості,
# які пристутні в обох рюкзаках друзів, лише в першому рюкзаку і лише в другому рюкзаку.
# first_backpack = {'water jacket': 1, 'cap': 1, 'dishes': 2, 'woolen gloves': 1, "tent": 1, 'first aid kit': 1, 'lighter': 2, 'sunglasses': 1, 'trousers': 2,
#                   'hygienic set': 1, 'flashlight': 1, 'footwear': 2, 'socks': 3, 'sleeping bag': 1
#                   }
#
# second_backpack ={'t-shirts': 3, 'first aid kit': 1, 'lighter': 2, 'batteries': 4, 'sunglasses': 1, 'trousers': 2,
#                   'hygienic set': 1, 'flashlight': 1, 'footwear': 2, 'socks': 3, 'poncho': 1, 'sleeping bag': 1
#                   }
#
# print('In both:')
# for thin, num in first_backpack.items():
#     if thin in first_backpack.keys() & second_backpack.keys():
#         print(thin, num)
# print('')
# print('Only in the first:')
# for thin, num in first_backpack.items():
#     if thin in first_backpack.keys() - second_backpack.keys():
#         print(thin, num)
# print('')
# print('Only in the other:')
# for thin, num in second_backpack.items():
#     if thin in second_backpack.keys() - first_backpack.keys():
#         print(thin, num)
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#597. У римській системі числення для позначення чисел використовуються наступні символи (праворуч записані числа, яким вони відповідають в десятковій системі числення):
#       I = 1
#       V = 5
#       X = 10
#       L = 50
#       C = 100
#       D = 500
#       M = 1000
# Будемо використовувати варіант, в якому числа 4, 9, 40, 90, 400 і 900 записуються як віднімання від більшого числа меншого:
# IV, IX, XL, XC, CD і CM, відповідно. Напишіть програму, яка за введеним натуральним числом n (0 < n < 4000) виведе рядок,
# що містить число, закодоване в римській системі числення.

num = 2025
from_num_to_rom_num = ''
rom_num = {1: 'I', 5: 'V', 10: 'X', 50: 'L',100: 'C', 500: 'D', 1000: 'M'}

thousands = num // 1000
hundreds = (num % 1000) // 100
tens = (num % 100) // 10
units = num % 10

#           for thousands
from_num_to_rom_num += thousands * rom_num[1000]

#           for hundreds
match hundreds:
    case hundreds if hundreds < 4:
        from_num_to_rom_num += rom_num[100] * hundreds
    case hundreds if hundreds == 4:
        from_num_to_rom_num += rom_num[100] + rom_num[500]
    case hundreds if hundreds == 5:
        from_num_to_rom_num += rom_num[500]
    case hundreds if 5 < hundreds < 9:
        from_num_to_rom_num += rom_num[500] + rom_num[100] * (hundreds - 5)
    case hundreds if hundreds == 9:
            from_num_to_rom_num += rom_num[100] + rom_num[1000]

#           for tens
match tens:
    case tens if tens < 4:
        from_num_to_rom_num += rom_num[10] * tens
    case tens if tens == 4:
        from_num_to_rom_num += rom_num[10] + rom_num[50]
    case tens if tens == 5:
        from_num_to_rom_num += rom_num[50]
    case tens if 5 < tens < 9:
        from_num_to_rom_num += rom_num[50] + rom_num[10] * (tens - 5)
    case tens if tens == 9:
            from_num_to_rom_num += rom_num[10] + rom_num[100]

#           for units
match units:
    case units if units < 4:
        from_num_to_rom_num += rom_num[1] * units
    case units if units == 4:
        from_num_to_rom_num += rom_num[1] + rom_num[5]
    case units if units == 5:
        from_num_to_rom_num += rom_num[5]
    case units if 5 < units < 9:
        from_num_to_rom_num += rom_num[5] + rom_num[1] * (units - 5)
    case units if units == 9:
            from_num_to_rom_num += rom_num[1] + rom_num[10]

print(from_num_to_rom_num)










































































































































